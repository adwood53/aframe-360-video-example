<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Camera Feed AR Scene</title>
    <script src="https://aframe.io/aframe/dist/aframe-master.js"></script>
    <script>
      AFRAME.registerComponent('follow-shadow', {
        schema: {type: 'selector'},
        init() {this.el.object3D.renderOrder = -1;},
        tick() {
          if (this.data) {
            this.el.object3D.position.copy(this.data.object3D.position);
            this.el.object3D.position.y-=0.001;
          }
        }
      });

      AFRAME.registerComponent('webcam-texture', {
        init: function() {
          // Handle both cases: permissions already granted and need to request
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
              .then(response => {
                if (response === 'granted') {
                  this.initializeWebcam();
                }
              })
              .catch(error => {
                console.warn('Permission flow failed:', error);
                // Try initializing anyway in case permissions were previously granted
                this.initializeWebcam();
              });
          } else {
            // No permission needed (e.g., non-iOS) or already granted
            this.initializeWebcam();
          }
        },

        initializeWebcam: function() {
          var video = document.createElement('video');
          video.setAttribute('autoplay', true);
          video.setAttribute('playsinline', true);
          video.setAttribute('webkit-playsinline', true);
          
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ 
              video: { 
                facingMode: 'environment',
                width: { ideal: 1280 },
                height: { ideal: 720 }
              } 
            })
            .then(stream => {
              video.srcObject = stream;
              video.play()
                .catch(error => console.error('Error playing video:', error));
            })
            .catch(error => {
              console.error('Camera error:', error);
              // Fallback to any available camera
              navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                  video.srcObject = stream;
                  video.play()
                    .catch(error => console.error('Error playing video:', error));
                })
                .catch(error => console.error('Fallback camera error:', error));
            });
          }

          var geometry = new THREE.PlaneGeometry(2, 2);
          var material = new THREE.MeshBasicMaterial({ 
            map: new THREE.VideoTexture(video),
            side: THREE.DoubleSide
          });
          var mesh = new THREE.Mesh(geometry, material);
          this.el.setObject3D('mesh', mesh);
          this.el.object3D.renderOrder = -2;
        }
      });

      AFRAME.registerComponent('interactive-model', {
        init: function() {
          this.el.addEventListener('model-loaded', () => {
            const obj = this.el.getObject3D('mesh');
            if (obj) {
              obj.traverse((node) => {
                if (node.isMesh) {
                  node.castShadow = true;
                  node.receiveShadow = true;
                }
              });
            }
          });

          this.el.addEventListener('click', this.onClick.bind(this));
        },
        
        onClick: function(evt) {
          evt.stopPropagation();
          evt.preventDefault();
        }
      });

      AFRAME.registerComponent('model-rotation-control', {
        init: function() {
          this.touchStart = { x: 0, y: 0 };
          // Initialize with 90 degrees (in radians)
          this.currentRotation = 90;
          this.isRotating = false;

          // Apply initial rotation
          this.el.object3D.rotation.y = THREE.MathUtils.degToRad(this.currentRotation);

          this.onTouchStart = this.onTouchStart.bind(this);
          this.onTouchMove = this.onTouchMove.bind(this);
          this.onTouchEnd = this.onTouchEnd.bind(this);

          document.addEventListener('touchstart', this.onTouchStart);
          document.addEventListener('touchmove', this.onTouchMove);
          document.addEventListener('touchend', this.onTouchEnd);

          // For desktop testing
          document.addEventListener('mousedown', this.onTouchStart);
          document.addEventListener('mousemove', this.onTouchMove);
          document.addEventListener('mouseup', this.onTouchEnd);
        },

        onTouchStart: function(evt) {
          this.isRotating = true;
          this.touchStart.x = evt.type === 'touchstart' ? evt.touches[0].clientX : evt.clientX;
        },

        onTouchMove: function(evt) {
          if (!this.isRotating) return;

          const currentX = evt.type === 'touchmove' ? evt.touches[0].clientX : evt.clientX;
          const deltaX = currentX - this.touchStart.x;
          
          // Adjust rotation sensitivity here
          const rotationDelta = deltaX * 0.5;
          
          this.el.object3D.rotation.y = THREE.MathUtils.degToRad(this.currentRotation + rotationDelta);
        },

        onTouchEnd: function() {
          if (this.isRotating) {
            this.isRotating = false;
            this.currentRotation = THREE.MathUtils.radToDeg(this.el.object3D.rotation.y);
          }
        },

        remove: function() {
          document.removeEventListener('touchstart', this.onTouchStart);
          document.removeEventListener('touchmove', this.onTouchMove);
          document.removeEventListener('touchend', this.onTouchEnd);
          document.removeEventListener('mousedown', this.onTouchStart);
          document.removeEventListener('mousemove', this.onTouchMove);
          document.removeEventListener('mouseup', this.onTouchEnd);
        }
      });

      AFRAME.registerComponent('camera-background', {
        init: function() {
          const backgroundEl = document.createElement('a-entity');
          backgroundEl.setAttribute('webcam-texture', '');
          backgroundEl.setAttribute('position', '0 0 -1');
          this.el.appendChild(backgroundEl);
        }
      });
    </script>
  </head>
  <body>
    <a-scene
      renderer="colorManagement: true; physicallyCorrectLights: true; exposure: 1; toneMapping: ACESFilmic"
      shadow="type: pcfsoft"
    >
      <a-assets>
        <a-asset-item id="model" src="public/your-model.glb"></a-asset-item>
      </a-assets>

      <a-light type="directional" light="castShadow:true;" position="1 1 1" intensity="1.57" shadow-camera-automatic="#model-container"></a-light>
      <a-camera camera-background position="0 0.4 0" wasd-controls="enabled: false"></a-camera>
      
      <a-entity 
        id="model-container" 
        position="0 0.5 -0.8" 
        scale="0.4 0.4 0.4" 
        rotation="0 90 0"
        model-rotation-control
        shadow>
        <a-entity
          gltf-model="#model"
          interactive-model
          shadow="cast: true; receive: true">
        </a-entity>
      </a-entity>
      
      <a-plane follow-shadow="#model-container" material="shader:shadow" shadow="cast:false;" rotation="-90 0 0" width="2" height="2"></a-plane>
    </a-scene>
  </body>
</html>
