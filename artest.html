<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>2 AR Model Viewer</title>
    <script src="https://aframe.io/aframe/dist/aframe-master.js"></script>
    <style>
      .control-buttons {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        display: flex;
        gap: 10px;
      }
      
      .control-btn {
        background: rgba(255, 255, 255, 0.9);
        border: none;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        font-size: 24px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        transition: all 0.3s ease;
      }

      .control-btn:hover {
        background: white;
        transform: scale(1.1);
      }

      .control-btn:active {
        transform: scale(0.95);
      }

      .reset-btn {
        font-size: 16px;
      }
    </style>
    <script>
      AFRAME.registerComponent('follow-shadow', {
        schema: {type: 'selector'},
        init() {
          this.el.object3D.renderOrder = -1;
        },
        tick() {
          if (this.data) {
            this.el.object3D.position.copy(this.data.object3D.position);
            this.el.object3D.position.y -= 0.001;
          }
        }
      });

      AFRAME.registerComponent('webcam-texture', {
        init: function() {
          var video = document.createElement('video');
          video.setAttribute('autoplay', true);
          video.setAttribute('playsinline', true);
          video.setAttribute('webkit-playsinline', true);
          
          if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
              .then(function(stream) {
                video.srcObject = stream;
                video.play();
              })
              .catch(function(error) {
                console.error('Camera error:', error);
              });
          }

          var geometry = new THREE.PlaneGeometry(2, 2);
          var material = new THREE.MeshBasicMaterial({ 
            map: new THREE.VideoTexture(video),
            side: THREE.DoubleSide
          });
          var mesh = new THREE.Mesh(geometry, material);
          this.el.setObject3D('mesh', mesh);
          this.el.object3D.renderOrder = -2;
        }
      });

      AFRAME.registerComponent('model-control', {
        schema: {
          defaultPosition: { type: 'vec3' },
          defaultRotation: { type: 'vec3' },
          defaultScale: { type: 'vec3' }
        },

        init: function() {
          this.touchStart = { x: 0, y: 0 };
          this.currentRotation = { y: 90, z: 0 };
          this.isRotating = false;
          this.currentZ = -0.8;  // Starting Z position

          // Bind methods
          this.onTouchStart = this.onTouchStart.bind(this);
          this.onTouchMove = this.onTouchMove.bind(this);
          this.onTouchEnd = this.onTouchEnd.bind(this);
          this.updatePosition = this.updatePosition.bind(this);
          this.resetModel = this.resetModel.bind(this);

          // Event listeners for touch/mouse
          document.addEventListener('contextmenu', (e) => e.preventDefault());
          document.addEventListener('touchstart', this.onTouchStart, { passive: false });
          document.addEventListener('touchmove', this.onTouchMove, { passive: false });
          document.addEventListener('touchend', this.onTouchEnd);
          document.addEventListener('mousedown', this.onTouchStart);
          document.addEventListener('mousemove', this.onTouchMove);
          document.addEventListener('mouseup', this.onTouchEnd);

          // Create UI controls
          this.createControls();
          
          // Set initial rotation
          this.updateRotation();
        },

        createControls: function() {
          const controls = document.createElement('div');
          controls.className = 'control-buttons';

          // Zoom out button
          const zoomOutBtn = document.createElement('button');
          zoomOutBtn.className = 'control-btn';
          zoomOutBtn.textContent = '-';
          zoomOutBtn.onclick = () => this.updatePosition(0.1);

          // Reset button
          const resetBtn = document.createElement('button');
          resetBtn.className = 'control-btn reset-btn';
          resetBtn.textContent = 'RESET';
          resetBtn.onclick = this.resetModel;

          // Zoom in button
          const zoomInBtn = document.createElement('button');
          zoomInBtn.className = 'control-btn';
          zoomInBtn.textContent = '+';
          zoomInBtn.onclick = () => this.updatePosition(-0.1);

          controls.appendChild(zoomOutBtn);
          controls.appendChild(resetBtn);
          controls.appendChild(zoomInBtn);
          document.body.appendChild(controls);
        },

        updatePosition: function(delta) {
          this.currentZ += delta;
          // Clamp position between -2 and -0.3
          this.currentZ = Math.max(-2, Math.min(-0.3, this.currentZ));
          this.el.object3D.position.z = this.currentZ;
        },

        resetModel: function() {
          this.currentZ = -0.8;
          this.currentRotation = { y: 90, z: 0 };
          this.el.object3D.position.z = this.currentZ;
          this.updateRotation();
        },

        updateRotation: function() {
          this.el.object3D.rotation.y = THREE.MathUtils.degToRad(this.currentRotation.y);
          this.el.object3D.rotation.z = THREE.MathUtils.degToRad(this.currentRotation.z);
        },

        onTouchStart: function(evt) {
          evt.preventDefault();
          this.isRotating = true;
          if (evt.type === 'touchstart') {
            this.touchStart.x = evt.touches[0].clientX;
            this.touchStart.y = evt.touches[0].clientY;
          } else {
            this.touchStart.x = evt.clientX;
            this.touchStart.y = evt.clientY;
          }
        },

        onTouchMove: function(evt) {
          if (!this.isRotating) return;
          evt.preventDefault();

          const currentX = evt.type === 'touchmove' ? evt.touches[0].clientX : evt.clientX;
          const currentY = evt.type === 'touchmove' ? evt.touches[0].clientY : evt.clientY;
          
          const deltaX = currentX - this.touchStart.x;
          const deltaY = currentY - this.touchStart.y;

          this.currentRotation.y += deltaX * 0.25;
          this.currentRotation.z += deltaY * 0.25;

          this.updateRotation();

          this.touchStart.x = currentX;
          this.touchStart.y = currentY;
        },

        onTouchEnd: function() {
          this.isRotating = false;
        },

        remove: function() {
          document.removeEventListener('touchstart', this.onTouchStart);
          document.removeEventListener('touchmove', this.onTouchMove);
          document.removeEventListener('touchend', this.onTouchEnd);
          document.removeEventListener('mousedown', this.onTouchStart);
          document.removeEventListener('mousemove', this.onTouchMove);
          document.removeEventListener('mouseup', this.onTouchEnd);
        }
      });

      AFRAME.registerComponent('camera-background', {
        init: function() {
          const backgroundEl = document.createElement('a-entity');
          backgroundEl.setAttribute('webcam-texture', '');
          backgroundEl.setAttribute('position', '0 0 -2');  // Moved back to -2
          this.el.appendChild(backgroundEl);
        }
      });
    </script>
  </head>
  <body>
    <a-scene
      renderer="colorManagement: true; physicallyCorrectLights: true; exposure: 1; toneMapping: ACESFilmic"
      shadow="type: pcfsoft"
    >
      <a-assets>
        <a-asset-item id="model" src="public/your-model.glb"></a-asset-item>
      </a-assets>

      <a-light type="directional" light="castShadow:true;" position="1 1 1" intensity="1.57" shadow-camera-automatic="#model-container"></a-light>
      <a-camera camera-background position="0 0.4 0" wasd-controls="enabled: false" look-controls="enabled: false"></a-camera>
      
      <a-entity 
        id="model-container" 
        position="0 0.5 -0.8" 
        scale="0.4 0.4 0.4" 
        rotation="0 90 0"
        model-control
        shadow>
        <!-- Front-facing model -->
        <a-entity
          gltf-model="#model"
          position="-0.2 0 0"
          shadow="cast: true; receive: true">
        </a-entity>
        <!-- Back-facing model -->
        <a-entity
          gltf-model="#model"
          position="0.2 0 0"
          rotation="0 180 0"
          shadow="cast: true; receive: true">
        </a-entity>
      </a-entity>
      
      <a-plane follow-shadow="#model-container" material="shader:shadow" shadow="cast:false;" rotation="-90 0 0" width="2" height="2"></a-plane>
    </a-scene>
  </body>
</html>
